\section{Déploiement}
\subsection{Études des différentes solutions}
\subsubsection{Heroku}
\subsubsection{Serveurs dédiés OVH}
\subsubsection{Justification du choix}
\subsection{Intégration Continue et Déploiement Continu}
\subsubsection{Docker}
Dans le but de rendre l'application portable, facilement configurable et cross-platform, j'ai decidé de dockeriser l'ensemble des composants constituant l'application, c'est à dire :
\begin{itemize}
    \item \textbf{masterservices-caddy} : Reverse-proxy
    \item \textbf{masterservices-app} : Web Server utilisant le port \textbf{8081}
    \item \textbf{masterservices-postgres} : Base de données utilisant le port \textbf{66453}
    \item \textbf{masterservices-redis} : Serveur pour gérer l'optimisation de l'application. Utilise le port \textbf{6379}
\end{itemize}
Le fonctionnement de chaque conteneur docker dépend des autres. Dans le cadre du projet, l'application sera fonctionnelle si la base de données et le serveur Redis sont opérationnels. Si l'un de ces deux serveurs fait défaut, l'application ne sera pas en mesure de fonctionner. 
Afin d'orchestrer les différents conteneurs, l'utilisation d'un docker-compose a été essentielle pour pouvoir, en une seule commande, créer et démarrer tous les services. 

Le seuls ports exposés à l'exterieur sont le port \textbf{80} et \textbf{443}, utilisé par le serveur caddy, ce qui est un premier pas de sécurisation de l'application. 
\subsubsection{Scripts}
\subsubsection{Github workflow}
